#!/usr/bin/env python


###############################################################################
### options
###############################################################################


import os
import sys
import argparse

sys.stdout.flush()

parser = argparse.ArgumentParser()

parser.add_argument("-d", "--description", 
    help="Get a description of what this script does.", 
    action="store_true")

parser.add_argument("-i", "--input", dest="path_in", metavar="PATH",
    help="Input folder, which is the path to the cuffdiff output folder.")
parser.add_argument("-o", "--output", dest="path_out", metavar="PATH",
    help="Output folder path. Default: 'go_david/'",
    default='go_david/')
#parser.add_argument("path_in", metavar="INPUT",
#    help="Input folder, which is the path to the cuffdiff output folder.")
#parser.add_argument("path_out", metavar="OUTPUT",
#    help="Output folder path.")
parser.add_argument("-u", "--user", 
    help="Your DAVID's user id. example: 'John.Doe@age.mpg.de'")
parser.add_argument("-g", "--gtf-original", dest="path_gtf_ori", metavar="PATH",
    help="Original/downloaded GTF")
parser.add_argument("-c", "--gtf-cuffcompare", dest="path_gtf_cuff", metavar="PATH",
    help="Merged cuffcompared GTF")



parser.add_argument("-f", "--files", dest='in_files', metavar="FILE[,FILE,...]",
    help="""A comma separated list of files for which analysis is performed.
    Must match one of the cuffdiff *.diff output files.
    Implies '-n'. 
    Default: 'gene_exp.diff,promoters.diff,splicing.diff,cds.diff,isoform_exp.diff'""", 
    default='gene_exp.diff,promoters.diff,splicing.diff,cds.diff,isoform_exp.diff')
parser.add_argument("-n", "--short-name", dest="short_name", metavar="NAME[,NAME,...]",
    help="""A comma separated list of short output names/labels. The values
    are related to those of the '-f' argument file list. No '.' (dots) allowed. 
    Default: 'geneexp,prom,splic,cds,iso'""",
    default='geneexp,prom,splic,cds,iso')

parser.add_argument("-s", "--sig_only", dest="sig_only",
    help="Only create report tables for cuffdiff-labeled significantly changed genes", 
    action="store_true")
parser.add_argument("-t", "--as-tsv", dest="as_tsv",
    help="For p values > = 1 write tables as tab separated values", 
    action="store_true")

parser.add_argument("--david-tag", dest="david_tag", metavar="ID", # david_tag ?
    help="""DAVID's id for your dataset. List of ids available at 
    http://david.abcc.ncifcrf.gov/content.jsp?file=DAVID_API.html#input_list
    Default: 'WORMBASE_GENE_ID'""",
    default='WORMBASE_GENE_ID')
parser.add_argument("--david-term", dest="david_term", metavar="CATEGORY", # david_term?
    help="""DAVID's categories you wish to analyse. List of available categories at
    https://david.ncifcrf.gov/content.jsp?file=DAVID_API.html#approved_list. 
    Default: 'GOTERM_BP_FAT,GOTERM_CC_FAT,GOTERM_MF_FAT,KEGG_PATHWAY,BIOCARTA,PFAM,PROSITE'""", 
    default='GOTERM_BP_FAT,GOTERM_CC_FAT,GOTERM_MF_FAT,KEGG_PATHWAY,BIOCARTA,PFAM,PROSITE')

args = parser.parse_args()

msg_desc = """
This script annotates gene_exp.diff, promoters.diff, splicing.diff, cds.diff, 
and isoform_exp.diff cuffdiff tables. It generates 1 file for all results, 1 
file for p<0.05, and 1 file/input table for q<0.05. 
For significant values (i.e. q<0.05) it also generates tables containg all 
pair-wise comparisons in different sheets as well as gene ontology enrichment
files for biological processes (BP), cellular component (CC), and molecular function (MF).

Required python packages:
a) pip install --user pandas==0.15.2
b) pip install --user numpy==1.9.2
c) pip install --user rpy2==2.5.6
d) pip install --user suds==0.4
e) pip install --user openpyxl==2.1.4

Required arguments: 
-i, -o, -G, -C

Example:
goDavid -u John.Doe@age.mpg.de \
-G /path/to/original.gtf -C /path/to/merged_and_compared.gtf \
-i /path/to/cuffdiff/ -o /path/to/result/

*************************************
Developed by Jorge Boucas at the group for Computational RNA Biology and Ageing
of the Max Planck Institute for Biology of Ageing
jorge.boucas@age.mpg.de
"""

if args.description:
  print msg_desc
  sys.exit(0)

url_client = 'https://david.ncifcrf.gov/webservice/services/DAVIDWebService?wsdl'
url_location = 'https://david.ncifcrf.gov/webservice/services/DAVIDWebService.DAVIDWebServiceHttpSoap11Endpoint/'
out_header = 'Category\tTerm\tCount\t%\tPvalue\tGenes\tList Total\tPop Hits\tPop Total\tFold Enrichment\tBonferroni\tBenjamini\tFDR\n'

import pandas as pd
import numpy as np
import time
from datetime import datetime
import shutil
from urllib import urlopen


###############################################################################
### functions
###############################################################################


def retrieve_GTF_field(field,gtf):
  field = pd.DataFrame(gtf[8].str.split(field).tolist())[1]
  field = field.astype(str)
  field = pd.DataFrame(field.str.split(';',1).tolist())
  field = pd.DataFrame(field[0].str.split('"').tolist())[1]
  field = pd.DataFrame(field)
  return field
# end retrieve_GTF_field


def DAVIDenrich(listF, idType, bgF='', resF='', bgName = 'Background1',
    listName='List1', category = '', thd=0.1, ct=2, msgi=6):
  #import ssl
  #ssl._create_default_https_context = ssl._create_unverified_context
  from suds.client import Client
  import os
  import ssl # fix
  ssl._create_default_https_context = ssl._create_unverified_context # fix
  if len(listF) > 0 and os.path.exists(listF):
    inputListIds = ','.join(open(listF).read().split('\n'))
    print " "*msgi + 'list loaded'
    sys.stdout.flush()
  else:
    print " "*msgi + 'no list loaded'
    sys.stdout.flush()
    raise
  flagBg = False
  if len(bgF) > 0 and os.path.exists(bgF):
    inputBgIds = ','.join(open(bgF).read().split('\n'))
    flagBg = True
    print " "*msgi + 'use file background'
    sys.stdout.flush()
  else:
    print " "*msgi + 'use default background'
    sys.stdout.flush()
  client = Client(url_client)
  client.wsdl.services[0].setlocation(url_location)
  print " "*msgi + 'user Authentication:',client.service.authenticate(args.user)
  sys.stdout.flush()
  listType = 0
  size=client.service.addList(inputListIds,idType,listName,listType)
  #print 'Percentage mapped(list):', client.service.addList(inputListIds,idType,listName,listType)
  print " "*msgi + 'percentage mapped(list): %s' %str(size)
  sys.stdout.flush()
  if float(size) > float(0):
    if flagBg:
      listType = 1
      print " "*msgi + 'percentage mapped(background):', client.service.addList(inputBgIds,idType,bgName,listType)
      sys.stdout.flush()
    print " "*msgi + 'use categories:', client.service.setCategories(category)
    sys.stdout.flush()
    chartReport = client.service.getChartReport(thd,ct)
    chartRow = len(chartReport)
    print " "*msgi + 'total chart records:',chartRow
    sys.stdout.flush()
    if len(resF) == 0 or not os.path.exists(resF):
      if flagBg:
        resF = listF + '.withBG.chartReport'
      else:
        resF = listF + '.chartReport'
    with open(resF, 'w') as fOut:
      fOut.write(out_header)
      for row in chartReport:
        rowDict = dict(row)
        categoryName = str(rowDict['categoryName'])
        termName = str(rowDict['termName'])
        listHits = str(rowDict['listHits'])
        percent = str(rowDict['percent'])
        ease = str(rowDict['ease'])
        Genes = str(rowDict['geneIds'])
        listTotals = str(rowDict['listTotals'])
        popHits = str(rowDict['popHits'])
        popTotals = str(rowDict['popTotals'])
        foldEnrichment = str(rowDict['foldEnrichment'])
        bonferroni = str(rowDict['bonferroni'])
        benjamini = str(rowDict['benjamini'])
        FDR = str(rowDict['afdr'])
        rowList = [
            categoryName,termName,listHits,percent,ease,Genes,listTotals,
            popHits,popTotals,foldEnrichment,bonferroni,benjamini,FDR]
        fOut.write('\t'.join(rowList)+'\n')
      print " "*msgi + 'write file:', resF, 'finished'
      sys.stdout.flush()
# end DAVIDenrich


def DAVIDget(cat, filtered_table, all_genes_table):
  IDs_table = pd.merge(filtered_table, all_genes_table, how='left', left_on='identifier', right_on='g_name')
  IDs_table = IDs_table[['g_id']].dropna()
  IDs_table.to_csv('targets_tmp.txt',sep='\t',header=False,index=False)
  background = all_genes_table[['g_id']].dropna()
  background.to_csv('background_tmp.txt',sep='\t',header=False,index=False)
  DAVIDenrich(listF = './targets_tmp.txt', bgF = './background_tmp.txt', 
      idType = DAVID_id, bgName = 'all_RNAseq_genes', listName = 'changed_genes', category = cat)
  if os.path.isfile('targets_tmp.txt.withBG.chartReport'):
    enrich=pd.read_csv('targets_tmp.txt.withBG.chartReport',sep='\t')
    os.remove('targets_tmp.txt.withBG.chartReport')
    terms=enrich['Term'].tolist()
    enrichN=pd.DataFrame()
    for term in terms:
      tmp=enrich[enrich['Term']==term]
      tmp=tmp.reset_index(drop=True)
      ids=tmp.xs(0)['Genes']
      ids=pd.DataFrame(data=ids.split(", "))
      ids.columns=['g_id']
      ids['g_id']=ids['g_id'].map(str.lower)
      all_genes_table['g_id']=all_genes_table['g_id'].map(str.lower)
      ids=pd.merge(ids, all_genes_table, how='left', left_on='g_id', right_on='g_id')
      names=ids['g_name'].tolist()
      names = ', '.join(names)
      tmp=tmp.replace(to_replace=tmp.xs(0)['Genes'], value=names)
      enrichN=pd.concat([enrichN, tmp])
    enrichN=enrichN.reset_index(drop=True)
  else:
    enrichN=pd.DataFrame()
  os.remove('targets_tmp.txt')
  os.remove('background_tmp.txt')
  return enrichN
# end DAVIDget


def DAVIDwrite(table_of_interest, name_vs_id_table, sheet_name):
  if len(table_of_interest.index) >= 1:
    enr = DAVIDget(args.david_term, table_of_interest, name_vs_id_table)
    if len(enr.index) >= 1:
      recovered_cats=list(set(enr['Category'].tolist()))
      for c in recovered_cats:
        enr[enr['Category']==c].to_csv(path_out+"/DAVID."+c+"_"+label+
            "_"+outshort+"."+sheet_name+".tmp",index=False, sep="\t")
# end DAVIDwrite


###############################################################################
### paths
###############################################################################


print "* checking paths"
if args.path_in is None:
  print "Error: supply '-o PATH'"
  sys.exit(65)
if args.path_gtf_ori is None:
  print "Error: supply '-g PATH'"
  sys.exit(65)
if args.path_gtf_cuff is None:
  print "Error: supply '-c PATH'"
  sys.exit(65)
if args.user is None:
  print "Error: supply '-u USER'"
  sys.exit(65)

path_in = os.path.realpath(args.path_in)
if not os.path.exists(path_in):
  print "Error: input path not found"
  sys.exit(65)

path_gtf_ori = os.path.realpath(args.path_gtf_ori)
path_gtf_cuff = os.path.realpath(args.path_gtf_cuff)
path_out = args.path_out

if not os.path.exists(path_out):
  os.makedirs(path_out)
path_out=os.path.realpath(path_out)

print "  input: " + path_in
sys.stdout.flush()
print "  output: " + path_out
sys.stdout.flush()
print "  gtf: "+path_gtf_ori
sys.stdout.flush()
print "  cuffcompare curated gtf: " + path_gtf_cuff
sys.stdout.flush()
print "  files: " + args.in_files
sys.stdout.flush()
print "  short names: "+args.short_name
sys.stdout.flush()

if args.sig_only:
  print "* reporting only significantly changed genes"
  sig_choice = ['yes']
  label_choice = ['diff_sig']
else:
  sig_choice = [0.05, 2, 'yes']
  label_choice = ['diff_p.05','diff_all','diff_sig']

print "* performing DAVID GO enrichment analysis"
print "* DAVID user id: " + args.user

sys.stdout.flush()

in_files=args.in_files
in_files=in_files.split(",")

short_name=args.short_name
short_name=short_name.split(",")

# Check DAVID's ID for your set:
# http://david.abcc.ncifcrf.gov/content.jsp?file=DAVID_API.html#input_list
DAVID_id=args.david_tag
os.chdir(path_in)


###############################################################################
### run: get gene names
###############################################################################


print "* getting gene name list"
if os.path.isfile(path_out+'/genes_table.txt'):
  print "  using already existing list"
  sys.stdout.flush()
  #genes=pd.read_table(path_out+'/genes_table.txt')
  #genes = genes['g_id'].tolist()
else:
  print "  getting list of gene names and respective ids present in the data set"
  sys.stdout.flush()
  genes = pd.DataFrame()
  for file in ['gene_exp.diff', 'promoters.diff', 'splicing.diff', 'cds.diff', 'isoform_exp.diff']:
    df = pd.read_table(file)
    df = df[['gene']]
    genes = pd.concat([genes,df]).drop_duplicates()
  genes = genes.astype(str)
  genes = pd.DataFrame(genes.gene.str.split(',').tolist())[0]
  genes = genes.drop_duplicates()
  genes = genes.tolist()
  print "  gene names imported"
  sys.stdout.flush()
  gtf = pd.read_table(path_gtf_ori, sep='\t', skiprows=6, header=None, dtype=str)
  print "  GTF imported"
  sys.stdout.flush()
  gtf = gtf.astype(str)
  gene_name = retrieve_GTF_field('gene_name',gtf)
  print "  read gene names from GTF"
  sys.stdout.flush()
  gene_id = retrieve_GTF_field('gene_id',gtf)
  print "  read gene ids from GTF"
  sys.stdout.flush()
  name_id = pd.concat([gene_name, gene_id], axis=1).drop_duplicates()
  name_id.columns = ['g_name','g_id']
  name_id = name_id[name_id['g_name'].isin(genes)]
  print "  generated reference table 'genes_table.txt'"
  sys.stdout.flush()
  #genes = name_id['g_id'].tolist()
  name_id.to_csv(path_out+'/genes_table.txt', sep="\t",index=False)
  del gtf, gene_name, gene_id, name_id

# create excel report tables
print "* creating report tables"
sys.stdout.flush()
name_id = pd.read_table(path_out+"/genes_table.txt", sep="\t")


###############################################################################
### run: GO enrichment for sign='yes'
###############################################################################


for sig, label in zip(sig_choice,label_choice):
  print "* processing sign=" + str(sig) 
  if sig != 'yes':
    if sig >= 1:
      if args.as_tsv:
        print "  using .tsv format"
      else:
        writer = pd.ExcelWriter(path_out+'/'+label+'.xlsx')
    else:
      writer = pd.ExcelWriter(path_out+'/'+label+'.xlsx')
    print "  writing xlsx"
    sys.stdout.flush()
  for imp, outshort in zip(in_files, short_name):
    print "  analysing " + imp
    df = pd.read_table(imp)
    if len(df) == 0:
      print "    %s table is empty. Make sure the GTF reference you used for cuffdiff contains p_ids." %imp
    else:
      sys.stdout.flush()
      if sig == 'yes':
        writer = pd.ExcelWriter(path_out+'/'+label+'_'+outshort+'.xlsx')
        print "    writing table " + label + "_" + outshort + ".xlsx"
        sys.stdout.flush()
      df = df.sort('p_value')
      df = df.sort('q_value')
      if sig == 'yes':
        df = df[df['significant'] == 'yes']
      else:
        df = df[df['p_value'] < sig]
      df = df.reset_index()
      df['gene'] = df['gene'].astype(str)
      tmp = pd.DataFrame(df.gene.str.split(',',1).tolist())
      tmp = pd.DataFrame(tmp.ix[:,0])
      tmp.columns = ['identifier']
      df = pd.concat([df,tmp], axis=1)
      if imp == 'isoform_exp.diff': # for isoform_exp.diff we want to have the transcript references
        gtf = pd.read_table(path_gtf_cuff, sep='\t', skiprows=6, header=None)
        t_id = retrieve_GTF_field('transcript_id',gtf)
        n_ref = retrieve_GTF_field('nearest_ref',gtf)
        id_ref = pd.concat([t_id, n_ref], axis=1).drop_duplicates()
        id_ref.columns = ['transcript_id','nearest_ref']
        df = pd.merge(id_ref, df, how='right', left_on='transcript_id', right_on='test_id')
        # for significant changes also report overlaps between the days, pair-wise, 
        # as well as go ontology enrichemnt for each table from DAVID
      if sig == 'yes':
        sample1 = df[['sample_1']]
        sample1.columns=['samples']
        sample2 = df[['sample_2']]
        sample2.columns=['samples']
        samples=pd.concat([sample1,sample2])
        samples=samples.drop_duplicates()
        samples=samples['samples'].tolist()
        readyList=[]
        print "    performing enrichment analysis"
        for sample1 in samples:
          for sample2 in samples:
            if sample1 != sample2:
              if sample1+sample2 not in readyList :
                if sample2+sample1 not in readyList :
                  readyList.append(sample1+sample2)
                  df_pair = df[df['sample_1'].isin([sample1,sample2])][df['sample_2'].isin([sample1,sample2])]
                  print "    comparison: " + sample1 + ' vs. ' + sample2
                  sys.stdout.flush()
                  DAVIDwrite(df_pair, name_id, sample1+'|'+sample2)
                  df_pair.drop(['test_id','index','gene_id','identifier'], axis=1, inplace=True)
                  if imp not in ['gene_exp.diff','isoform_exp.diff']:
                    df_pair.drop(['value_1','value_2','test_stat'], axis=1, inplace=True)
                  df_pair.to_excel(writer, sample1+'|'+sample2, index=False)

      df.drop(['test_id','index','gene_id','identifier'], axis=1, inplace=True)
      if imp not in ['gene_exp.diff','isoform_exp.diff']:
        df.drop(['value_1','value_2','test_stat'], axis=1, inplace=True)
      if sig == 'yes':
        df.to_excel(writer, 'ALL', index=False)
        writer.save()

    if sig != 'yes':
      if sig >= 1:
        if args.as_tsv:
          df.to_csv(outshort+'_'+'ALL.tsv', index=False)
        else:
          df.to_excel(writer, outshort+'_'+'ALL', index=False)

      else:
        df.to_excel(writer, outshort+'_'+'ALL', index=False)

  if sig != 'yes':
    if sig >= 1:
      if args.as_tsv:
        print "For "+str(label)+" files were saved as tsv"
      else:
        writer.save()
    else:
      writer.save()

DAVID_tmp_files=os.listdir(path_out)
DAVID_tmp_files=[ s for s in DAVID_tmp_files if "DAVID" in s ]
DAVID_tmp_files=[ s for s in DAVID_tmp_files if "tmp" in s ]
cat_to_exc=[]
for f in DAVID_tmp_files:
  c=f.split(".")[1]
  cat_to_exc.append(c)
cat_to_exc=list(set(cat_to_exc))
for c in cat_to_exc:
  writer = pd.ExcelWriter(path_out+'/'+c+'.xlsx')
  cat_files=[s for s in DAVID_tmp_files if c in s]
  for f in cat_files:
    df=pd.read_table(path_out+'/'+f)
    sheet_name=f.split(".")[2]
    df.to_excel(writer, sheet_name, index=False)
  writer.save()

print "* removing tmp files"
for f in DAVID_tmp_files:
  print "  file " + f
  os.remove(path_out+'/'+f)


print "\n\nDone\n"
print """*************************************
Developed by Jorge Boucas at the group for Computational RNA Biology and Ageing
of the Max Planck Institute for Biology of Ageing

jorge.boucas@age.mpg.de
"""
sys.exit()
